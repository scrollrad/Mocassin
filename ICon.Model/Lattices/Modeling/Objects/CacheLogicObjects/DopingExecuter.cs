using Mocassin.Model.Particles;
using System;
using System.Collections.Generic;
using System.Text;
using Mocassin.Framework.Collections;

using ICon.Framework.Random;
using ICon.Mathematics.Comparers;
using System.Linq;

using ICon.Framework.Extensions;

namespace ICon.Model.Lattices
namespace Mocassin.Model.Lattices
{
    /// <summary>
    /// Executes dopings on the Worklattice
    /// </summary>
    /// <remarks>
    /// The doping executer applies provided dopings with concentrations to a provided lattice. The lattice is a multidimensional
    /// jagged array of LatticeEntries and has the structure of unitcells ordered in a supercell. The user may define simutaneous and
    /// subsequental doping, thus a doping order is calculated and applied successively. For the doping process itself position pools are
    /// first generated by iterating through the lattice and ordered in a dictionary. Then the particle count of dopant 
    /// and counter dopant are calculated.Finally random entries are selected from the  corresponding position pools and their occupation 
    /// altered. By this the entries in the provided lattice are also altered. The altered entries are subjequently removed from the position pool.
    /// </remarks>
    public class DopingExecuter
    {
        /// <summary>
        /// Contains information about positions which can be doped and the original number of these
        /// </summary>
        protected class PositionPool
        /// <param name="lattice"></param>
        /// <param name="dopings"></param>
        public void ExecuteMultible(WorkLattice lattice, ReadOnlyListAdapter<IDoping> dopings)
>>>>>>> origin/s.eisele@dev
        {
            public int OriginalSize { get; set; }
            public List<LatticeEntry> Entries { get; set; }
        }

        /// <summary>
        /// Double comparer
        /// </summary>
        DoubleRangeComparer Comparer { get; }

        /// <summary>
        /// Doping tolerance value
        /// </summary>
        double DopingTolerance { get; }

        /// <summary>
        /// Random generator
        /// </summary>
        public Random RandomGenerator { get; set; }

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="doubleCompareTolerance"></param>
        /// <param name="dopingTolerance"></param>
        /// <param name="randomGenerator"></param>
        public DopingExecuter(double doubleCompareTolerance, double dopingTolerance, Random randomGenerator)
        {
            Comparer = new DoubleRangeComparer(doubleCompareTolerance);
            DopingTolerance = dopingTolerance;
            RandomGenerator = randomGenerator;
        }

        /// <summary>
        /// Execute the doping process for multiple dopings to a worklattice
        /// </summary>
        /// <param name="lattice"></param>
        /// <param name="dopings"></param>
        public void DopeLattice(LatticeEntry[,,][] lattice, ReadOnlyList<IDoping> dopings, IDictionary<IDoping, double> dopingConcentrations)
        {
            var orderedDopings = GenerateDopingOrder(dopings);

            foreach (var dopingID in (orderedDopings.Keys.OrderBy(x => x)))
            {
                var dopingPool = GeneratePositionPool(lattice);

                foreach(var doping in orderedDopings[dopingID])
                {
                    Execute(doping, dopingConcentrations[doping], dopingPool);
                }
            }

        }

        /// <summary>
        /// Generates the order of doping for simutaneous and consecutive dopings
        /// </summary>
        /// <param name="dopings"></param>
        /// <returns></returns>
        protected Dictionary<int, List<IDoping>> GenerateDopingOrder(ICollection<IDoping> dopings)
        {
            var orderedDopings = new Dictionary<int, List<IDoping>>();
            foreach (var doping in dopings)
            {
                if (orderedDopings.ContainsKey(doping.DopingGroup) == false)
                {
                    orderedDopings[doping.DopingGroup] = new List<IDoping>();
                }
                orderedDopings[doping.DopingGroup].Add(doping);
            }

            return orderedDopings;
        }

        /// <summary>
        /// Generate a position pool for every occuring LatticeEntry
        /// </summary>
        /// <param name="lattice"></param>
        /// <returns></returns>
        protected Dictionary<LatticeEntry, PositionPool> GeneratePositionPool(LatticeEntry[,,][] lattice)
        {
            var dopingPoolDict = new Dictionary<LatticeEntry, PositionPool>();

            foreach (var cell in lattice)
            {
                foreach(var entry in cell)
                {
                    if (dopingPoolDict.ContainsKey(entry) == false)
                    {
                        dopingPoolDict[entry.ShallowCopy()] = new PositionPool() { OriginalSize = 0, Entries = new List<LatticeEntry>() };
                    }

                    dopingPoolDict[entry].OriginalSize += 1;
                    dopingPoolDict[entry].Entries.Add(entry);
                }
            }

            return dopingPoolDict;
        }

        /// <summary>
        /// Execute the doping process
        /// </summary>
        /// <param name="lattice"></param>
        /// <param name="doping"></param>
        protected void Execute(IDoping doping, double concentration, Dictionary<LatticeEntry, PositionPool> dopingPool)
        {
            LatticeEntry dopedCellEntry = new LatticeEntry()
            {
                Particle = doping.DopingInfo.DopedParticle,
                CellPosition = doping.DopingInfo.UnitCellPosition,
                Block = doping.DopingInfo.BuildingBlock,
            };

            LatticeEntry counterDopedCellEntry = new LatticeEntry()
            {
                Particle = doping.CounterDopingInfo.DopedParticle,
                CellPosition = doping.CounterDopingInfo.UnitCellPosition,
                Block = doping.CounterDopingInfo.BuildingBlock,
            };

            (int,int) dopingParticleCount = CalculateDopingCount(dopingPool[dopedCellEntry].OriginalSize, dopingPool[counterDopedCellEntry].OriginalSize, doping, concentration);

            ApplyDoping(dopingPool[dopedCellEntry].Entries, dopingParticleCount.Item1, doping.DopingInfo);

            ApplyDoping(dopingPool[counterDopedCellEntry].Entries, dopingParticleCount.Item2, doping.CounterDopingInfo);
        }

        /// <summary>
        /// Apply Doping to the PositionPool (and therefore to the WorkLattice)
        /// </summary>
        /// <param name="dopableCellEntries"></param>
        /// <param name="dopingParticleCount"></param>
        /// <param name="doping"></param>
        protected void ApplyDoping(List<LatticeEntry> dopableCellEntries, int dopingParticleCount, IDopingCombination doping)
        {
            List<int> dopedEntriesIndex = dopableCellEntries.SelectRandomIndex(dopingParticleCount, RandomGenerator).ToList();

            for(int index = dopedEntriesIndex.Count-1; index >= 0; index--)
            {
                dopableCellEntries[dopedEntriesIndex[index]].Particle = doping.Dopant;
                dopableCellEntries.RemoveAt(dopedEntriesIndex[index]);
            }
        }

        /// <summary>
        /// Calculate the number of counter dopants
        /// </summary>
        /// <param name="dopableCellEntriesCount"></param>
        /// <param name="doping"></param>
        /// <returns></returns>
        public (int,int) CalculateDopingCount(int dopableCount, int counterDopableCount, IDoping doping, double concentration)
        {
            double counterDopingMultiplier;
            if (doping.UseCustomMultiplier == false)
            {
                counterDopingMultiplier = CalculateChargeBasedMultiplier(doping);
            }
            else
            {
                counterDopingMultiplier = doping.CounterDopingMultiplier;
            }

            int dopandCount = (int)(Math.Round(dopableCount * concentration));

            if (doping.UseCounterDoping == false)
            {
                return (dopandCount, 0);
            }

            double counterDopandCount = dopandCount * counterDopingMultiplier;

            if ( Comparer.Compare(counterDopandCount % 1, 0) == 0)
            {
                return (dopandCount, (int)counterDopandCount);
            }

            for (int i = 0; i <= (int)(dopandCount * DopingTolerance); i++)
            {
                counterDopandCount = (dopandCount + i) * counterDopingMultiplier;

                if (Comparer.Compare(counterDopandCount % 1, 0) == 0)
                {
                    return (dopandCount+i, (int)counterDopandCount);
                }

                counterDopandCount = (dopandCount - i) * counterDopingMultiplier;

                if (Comparer.Compare(counterDopandCount % 1, 0) == 0)
                {
                    return (dopandCount + i, (int)counterDopandCount);
                }
            }

            counterDopandCount = (Math.Round(dopandCount * counterDopingMultiplier));
            return (dopandCount, (int)counterDopandCount);
        }

        /// <summary>
        /// Calculate the counter doping multiplier based on the charge
        /// </summary>
        /// <param name="doping"></param>
        /// <returns></returns>
        public double CalculateChargeBasedMultiplier(IDoping doping)
        {
            double DeltaChargeDopant = doping.DopingInfo.Dopant.Charge - doping.DopingInfo.DopedParticle.Charge;
            double DeltaChargeCounterDopant = doping.CounterDopingInfo.Dopant.Charge - doping.CounterDopingInfo.DopedParticle.Charge;

            if (Comparer.Compare((DeltaChargeDopant - DeltaChargeCounterDopant),0) == 0)
            {
                return 1.0;
            }
            if (DeltaChargeDopant == 0 || DeltaChargeCounterDopant == 0)
            {
                throw new ArgumentException("DopingExecuter", "Inconsistent doping! Only one doping is charge neutral!");
            }

            return Math.Abs(DeltaChargeDopant / DeltaChargeCounterDopant);
        }
    }


}
