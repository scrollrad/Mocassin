using System;
using Mocassin.Mathematics.ValueTypes;

namespace Moccasin.Mathematics.ValueTypes
{
    /// <summary>
    ///     Represents a readonly set of A,B,C offset integers in a 3D translation invariant coordinate system
    /// </summary>
    public readonly struct VectorI3
    {
        /// <summary>
        ///     Get the X coordinate value
        /// </summary>
        public int A { get; }

        /// <summary>
        ///     Get the Y coordinate value
        /// </summary>
        public int B { get; }

        /// <summary>
        ///     Get the Z coordinate value
        /// </summary>
        public int C { get; }

        /// <summary>
        ///     Construct from A,B,C coordinate values
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <param name="c"></param>
        public VectorI3(int a, int b, int c)
            : this()
        {
            A = a;
            B = b;
            C = c;
        }

        /// <summary>
        ///     Construct from DataIntVector3D
        /// </summary>
        /// <param name="vector"></param>
        public VectorI3(DataIntVector3D vector)
            : this(vector.A, vector.B, vector.C)
        {
        }

        /// <summary>
        ///     Vector addition
        /// </summary>
        /// <param name="lhs"></param>
        /// <param name="rhs"></param>
        /// <returns></returns>
        public static VectorI3 operator +(VectorI3 lhs, VectorI3 rhs)
        {
            return new VectorI3(lhs.A + rhs.A, lhs.B + rhs.B, lhs.C + rhs.C);
        }

        /// <summary>
        ///     Vector subtraction
        /// </summary>
        /// <param name="lhs"></param>
        /// <param name="rhs"></param>
        /// <returns></returns>
        public static VectorI3 operator -(VectorI3 lhs, VectorI3 rhs)
        {
            return new VectorI3(lhs.A - rhs.A, lhs.B - rhs.B, lhs.C - rhs.C);
        }

        /// <summary>
        ///     Scalar product of two cartesian vectors
        /// </summary>
        /// <param name="lhs"></param>
        /// <param name="rhs"></param>
        /// <returns></returns>
        public static double operator *(VectorI3 lhs, VectorI3 rhs)
        {
            return lhs.A * rhs.A + lhs.B * rhs.B + lhs.C * rhs.C;
        }

        /// <summary>
        ///     Multiplication with scalar value
        /// </summary>
        /// <param name="lhs"></param>
        /// <param name="scalar"></param>
        /// <returns></returns>
        public static VectorI3 operator *(VectorI3 lhs, int scalar)
        {
            return new VectorI3(lhs.A * scalar, lhs.B * scalar, lhs.C * scalar);
        }

        /// <summary>
        ///     Division by scalar value
        /// </summary>
        /// <param name="lhs"></param>
        /// <param name="scalar"></param>
        /// <returns></returns>
        public static VectorI3 operator /(VectorI3 lhs, int scalar)
        {
            return new VectorI3(lhs.A / scalar, lhs.B / scalar, lhs.C / scalar);
        }

        /// <summary>
        ///     Division by vector
        /// </summary>
        /// <param name="lhs"></param>
        /// <param name="rhs"></param>
        /// <returns></returns>
        public static VectorI3 operator /(VectorI3 lhs, VectorI3 rhs)
        {
            return new VectorI3(lhs.A / rhs.A, lhs.B / rhs.B, lhs.C / rhs.C);
        }

        /// <summary>
        ///     Remainder operation of every component by scalar value
        /// </summary>
        /// <param name="lhs"></param>
        /// <param name="scalar"></param>
        /// <returns></returns>
        public static VectorI3 operator %(VectorI3 lhs, int scalar)
        {
            return new VectorI3(lhs.A % scalar, lhs.B % scalar, lhs.C % scalar);
        }

        /// <summary>
        ///     Remainder operation of every component by scalar value
        /// </summary>
        /// <param name="lhs"></param>
        /// <param name="rhs"></param>
        /// <returns></returns>
        public static VectorI3 operator %(VectorI3 lhs, VectorI3 rhs)
        {
            return new VectorI3(lhs.A % rhs.A, lhs.B % rhs.B, lhs.C % rhs.C);
        }

        /// <summary>
        ///     Get the length of the vector
        /// </summary>
        /// <returns></returns>
        public double GetLength()
        {
            return Math.Sqrt(A * A + B * B + C * C);
        }

        /// <summary>
        ///     Get the volume of a cuboid generated by this vector
        /// </summary>
        /// <returns></returns>
        public int GetCoordinateProduct()
        {
            return A * B * C;
        }

        /// <summary>
        ///     Compares the components of two vectors for equality
        /// </summary>
        /// <param name="vector"></param>
        /// <returns></returns>
        public bool Equals(in VectorI3 vector)
        {
            return A == vector.A && B == vector.B && C == vector.C;
        }
    }
}